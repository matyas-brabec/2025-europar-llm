#include <cuda_runtime.h>

// Define the block size for kernel execution.
// A block size of 32x32 threads is typically optimal on modern NVIDIA GPUs.
#define BLOCK_SIZE 32

// CUDA kernel implementing one step of Conway's Game of Life without using shared or texture memory.
// Each thread processes a single cell by reading its eight neighbors directly from global memory.
__global__ void game_of_life_kernel(const bool* input, bool* output, int grid_dim) {
    // Calculate the global coordinates for the cell handled by this thread.
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;

    // Ensure the thread is within the bounds of the grid.
    if (x >= grid_dim || y >= grid_dim)
        return;

    // Count the number of alive neighbors.
    // Neighbors include the eight adjacent cells (horizontal, vertical, and diagonal).
    int alive_neighbors = 0;
    for (int dy = -1; dy <= 1; dy++) {
        int neighbor_y = y + dy;
        // Skip out-of-bound rows.
        if (neighbor_y < 0 || neighbor_y >= grid_dim)
            continue;
        for (int dx = -1; dx <= 1; dx++) {
            int neighbor_x = x + dx;
            // Skip out-of-bound columns.
            if (neighbor_x < 0 || neighbor_x >= grid_dim)
                continue;
            // Skip the cell itself.
            if (dx == 0 && dy == 0)
                continue;
            // Each neighbor contributes 1 if alive, 0 if dead.
            alive_neighbors += input[neighbor_y * grid_dim + neighbor_x];
        }
    }

    // Retrieve the current state of the cell.
    bool current = input[y * grid_dim + x];
    bool next_state = false;

    // Apply the rules of Conway's Game of Life:
    // - Any alive cell with 2 or 3 alive neighbors survives.
    // - Any dead cell with exactly 3 alive neighbors becomes alive.
    // - Otherwise, the cell dies or remains dead.
    if (current) {
        next_state = (alive_neighbors == 2 || alive_neighbors == 3);
    } else {
        next_state = (alive_neighbors == 3);
    }

    // Write the computed next state back to global memory.
    output[y * grid_dim + x] = next_state;
}

// Host function to launch the CUDA kernel for one step of Conway's Game of Life.
// This function calculates the grid and block dimensions and launches the kernel.
// The input and output pointers are assumed to point to device memory allocated using cudaMalloc.
void run_game_of_life(const bool* input, bool* output, int grid_dimensions) {
    // Define the block dimensions.
    dim3 block(BLOCK_SIZE, BLOCK_SIZE);
    // Calculate the grid dimensions to cover the entire grid.
    dim3 grid((grid_dimensions + block.x - 1) / block.x,
              (grid_dimensions + block.y - 1) / block.y);

    // Launch the kernel. Any necessary host-device synchronization is assumed to be handled externally.
    game_of_life_kernel<<<grid, block>>>(input, output, grid_dimensions);
}

// The content below was not generated by GPT; it was added to ensure the framework can compile the code.

#include <cstdint>
void run_game_of_life(const std::uint64_t* input, std::uint64_t* output, int grid_dimensions) {
    (void)input;
    (void)output;
    (void)grid_dimensions;
}

void initialize_internal_data_structures(int grid_dimensions) {
    (void)grid_dimensions;
}
// this label is used to identify the memory layout of the input and output arrays by the framework
// MEMORY_LAYOUT: BOOLS

