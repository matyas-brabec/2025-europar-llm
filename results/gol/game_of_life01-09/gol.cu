#include <cuda_runtime.h>

#define BLOCK_SIZE 32  // Optimal block size for modern NVIDIA GPUs like A100/H100

// CUDA kernel that computes one generation of Conway's Game of Life.
// This kernel uses shared memory tiling to reduce global memory accesses.
// Each block processes a BLOCK_SIZE x BLOCK_SIZE tile of the grid.
// To correctly compute neighbors, each block loads a tile with a 1-cell-wide halo.
__global__ void game_of_life_kernel(const bool* __restrict__ input,
                                    bool* __restrict__ output,
                                    int grid_dim) {
    // Shared memory tile size: (BLOCK_SIZE + 2) x (BLOCK_SIZE + 2)
    // The extra border cells (halo) are required for neighbor accesses.
    __shared__ bool tile[BLOCK_SIZE + 2][BLOCK_SIZE + 2];

    // Total shared memory tile width.
    const int tile_width = BLOCK_SIZE + 2;
    // Compute a unique thread index within the block.
    const int thread_id = threadIdx.y * blockDim.x + threadIdx.x;
    const int total_threads = blockDim.x * blockDim.y;

    // Each thread cooperatively loads multiple elements of the shared tile.
    // We use a strided loop to cover all tile elements, including the halo.
    // For each shared tile element, compute its corresponding global coordinates.
    for (int idx = thread_id; idx < tile_width * tile_width; idx += total_threads) {
        int local_row = idx / tile_width;
        int local_col = idx % tile_width;
        // Map the shared memory coordinates to global grid coordinates.
        // The tile is offset by (-1, -1) to load the halo.
        int global_row = blockIdx.y * BLOCK_SIZE + local_row - 1;
        int global_col = blockIdx.x * BLOCK_SIZE + local_col - 1;
        // If the global coordinate is within bounds, load the cell state; otherwise, treat as dead.
        bool cell = false;
        if (global_row >= 0 && global_row < grid_dim && global_col >= 0 && global_col < grid_dim) {
            cell = input[global_row * grid_dim + global_col];
        }
        tile[local_row][local_col] = cell;
    }
    // Ensure all threads have completed loading into shared memory.
    __syncthreads();

    // Compute global coordinates for the cell assigned to each thread within the main tile.
    int global_row = blockIdx.y * BLOCK_SIZE + threadIdx.y;
    int global_col = blockIdx.x * BLOCK_SIZE + threadIdx.x;

    // Only process valid grid cells.
    if (global_row < grid_dim && global_col < grid_dim) {
        // The corresponding location in shared memory (excluding the halo) is offset by +1.
        int local_row = threadIdx.y + 1;
        int local_col = threadIdx.x + 1;

        // Sum the states of the 8 neighboring cells from shared memory.
        int neighbors = 0;
        neighbors += tile[local_row - 1][local_col - 1];  // Top-left
        neighbors += tile[local_row - 1][local_col];      // Top
        neighbors += tile[local_row - 1][local_col + 1];  // Top-right
        neighbors += tile[local_row][local_col - 1];      // Left
        neighbors += tile[local_row][local_col + 1];      // Right
        neighbors += tile[local_row + 1][local_col - 1];  // Bottom-left
        neighbors += tile[local_row + 1][local_col];      // Bottom
        neighbors += tile[local_row + 1][local_col + 1];  // Bottom-right

        // Apply Conway's Game of Life rules:
        // - An alive cell survives with 2 or 3 live neighbors.
        // - A dead cell becomes alive with exactly 3 live neighbors.
        bool current = tile[local_row][local_col];
        bool next_state = (neighbors == 3) || (current && neighbors == 2);

        // Write the computed state back to the output grid in global memory.
        output[global_row * grid_dim + global_col] = next_state;
    }
}

// Host function that executes one step of Conway's Game of Life.
// 'input' and 'output' point to device memory (allocated via cudaMalloc) holding the grid state.
// 'grid_dimensions' is the width and height of the square grid.
void run_game_of_life(const bool* input, bool* output, int grid_dimensions) {
    // Configure block dimensions: BLOCK_SIZE x BLOCK_SIZE threads per block.
    dim3 blockDim(BLOCK_SIZE, BLOCK_SIZE);
    // Compute grid dimensions; using ceiling division in case grid_dimensions is not an exact multiple of BLOCK_SIZE.
    dim3 gridDim((grid_dimensions + BLOCK_SIZE - 1) / BLOCK_SIZE,
                 (grid_dimensions + BLOCK_SIZE - 1) / BLOCK_SIZE);

    // Launch the kernel. The shared memory size is automatically deduced from the static allocation.
    game_of_life_kernel<<<gridDim, blockDim>>>(input, output, grid_dimensions);
    // Host-device synchronization is assumed to be handled by the caller.
}

// The content below was not generated by GPT; it was added to ensure the framework can compile the code.


#include <cstdint>
void run_game_of_life(const std::uint64_t* input, std::uint64_t* output, int grid_dimensions) {
    (void)input;
    (void)output;
    (void)grid_dimensions;
}

void initialize_internal_data_structures(int grid_dimensions) {
    (void)grid_dimensions;
}
// this label is used to identify the memory layout of the input and output arrays by the framework
// MEMORY_LAYOUT: BOOLS
