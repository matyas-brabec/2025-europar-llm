#include <cstdint>
#include <cuda_runtime.h>

/*
  CUDA implementation of one step of Conway's Game of Life on a bit-packed grid.

  - Each std::uint64_t encodes 64 cells (one bit per cell). Bit order is
    assumed to be least-significant-bit = column 0, up to bit 63 = column 63 in the word.
  - The grid is square with dimension grid_dimensions, and words_per_row = grid_dimensions / 64.
  - Each CUDA thread processes exactly one 64-bit word (i.e., 64 cells) from the input grid.
  - Boundary conditions: cells outside the grid are considered dead (0).

  Algorithm overview:

  For the 64 cells in a word at position (row r, word column w), the eight neighbor bitboards are formed
  by considering the three rows r-1, r, r+1 and shifting the words to align the horizontal neighbors:
    - From the row above (north):      N_left, N_center, N_right
    - From the same row (center row):  C_left, C_right      (C_center excluded to avoid counting the cell itself)
    - From the row below (south):      S_left, S_center, S_right

  The left and right bitboards are generated by 1-bit shifts with cross-word carry-in/out:
    - left shift:  (center_word << 1) | (left_word >> 63)
    - right shift: (center_word >> 1) | (right_word << 63)

  Lane-wise (bit-sliced) addition:
    We sum the eight 1-bit neighbor masks without cross-bit carry using carry-save adders (CSA).
    This yields three bitplanes (ones, twos, fours) representing the neighbor count modulo 8:
      count = ones + 2*twos + 4*fours  (mod 8, overflow at 8 neighbors is dropped which is fine for Life rules)
    Then:
      births  = (count == 3) = (~fours) & twos & ones
      survives= (count == 2) = (~fours) & twos & (~ones)
    The next state is: births | (survives & current).

  Note:
    - We do not include shared or texture memory, as random access patterns and per-thread 9-word loads
      are typically well-served by the L1/L2 caches on modern NVIDIA GPUs (A100/H100).
    - We avoid atomics by mapping one thread to one 64-bit word.
    - Reads use __ldg to hint the read-only data cache for the input grid.
*/

/* Carry-save adder for three 64-bit bitboards.
   sum = a ^ b ^ c         (bitwise sum modulo 2, i.e., "ones" at each bit-lane)
   carry = (a&b)|(b&c)|(a&c)  (bitwise carry, i.e., "twos" at each bit-lane)
   This operates lane-wise: there is no cross-bit carry.
*/
static __device__ __forceinline__ void csa_u64(const std::uint64_t a,
                                               const std::uint64_t b,
                                               const std::uint64_t c,
                                               std::uint64_t &sum,
                                               std::uint64_t &carry)
{
    const std::uint64_t u = a ^ b;
    sum   = u ^ c;
    carry = (a & b) | (c & u);
}

/* 1-bit left shift with cross-word carry from the left word.
   - c: center word
   - l: left adjacent word (0 if none)
   Returns: (c << 1) | (l >> 63)
*/
static __device__ __forceinline__ std::uint64_t shl1_with_carry(const std::uint64_t c, const std::uint64_t l)
{
    return (c << 1) | (l >> 63);
}

/* 1-bit right shift with cross-word carry from the right word.
   - c: center word
   - r: right adjacent word (0 if none)
   Returns: (c >> 1) | (r << 63)
*/
static __device__ __forceinline__ std::uint64_t shr1_with_carry(const std::uint64_t c, const std::uint64_t r)
{
    return (c >> 1) | (r << 63);
}

/* Read-only cached load for 64-bit from global memory. */
static __device__ __forceinline__ std::uint64_t ld64_cg(const std::uint64_t* ptr)
{
    return __ldg(ptr);
}

/* Kernel: One step of Conway's Game of Life on a bit-packed grid. */
__global__ void gol_step_kernel(const std::uint64_t* __restrict__ input,
                                std::uint64_t* __restrict__ output,
                                int grid_dim_cells,          // number of rows/cols (cells)
                                int words_per_row)           // number of 64-bit words per row
{
    const std::size_t total_words = static_cast<std::size_t>(grid_dim_cells) * static_cast<std::size_t>(words_per_row);

    for (std::size_t idx = static_cast<std::size_t>(blockIdx.x) * blockDim.x + threadIdx.x;
         idx < total_words;
         idx += static_cast<std::size_t>(blockDim.x) * gridDim.x)
    {
        // Compute (row, word-column) for this word.
        const int row = static_cast<int>(idx / words_per_row);
        const int wcol = static_cast<int>(idx - static_cast<std::size_t>(row) * words_per_row);

        // Boundary flags
        const bool hasN = (row > 0);
        const bool hasS = (row + 1 < grid_dim_cells);
        const bool hasL = (wcol > 0);
        const bool hasR = (wcol + 1 < words_per_row);

        // Base offsets for rows (guarded by hasN/hasS)
        std::size_t baseC = static_cast<std::size_t>(row) * words_per_row;
        std::size_t baseN = 0, baseS = 0;
        if (hasN) baseN = static_cast<std::size_t>(row - 1) * words_per_row;
        if (hasS) baseS = static_cast<std::size_t>(row + 1) * words_per_row;

        // Load the 3x3 neighborhood of words (missing neighbors are zero).
        // North row
        const std::uint64_t nL = (hasN && hasL) ? ld64_cg(input + baseN + (wcol - 1)) : 0ull;
        const std::uint64_t nC = (hasN)         ? ld64_cg(input + baseN + wcol)       : 0ull;
        const std::uint64_t nR = (hasN && hasR) ? ld64_cg(input + baseN + (wcol + 1)) : 0ull;

        // Center row (current word and its left/right neighbors)
        const std::uint64_t cL = (hasL)         ? ld64_cg(input + baseC + (wcol - 1)) : 0ull;
        const std::uint64_t cC =                  ld64_cg(input + baseC + wcol);
        const std::uint64_t cR = (hasR)         ? ld64_cg(input + baseC + (wcol + 1)) : 0ull;

        // South row
        const std::uint64_t sL = (hasS && hasL) ? ld64_cg(input + baseS + (wcol - 1)) : 0ull;
        const std::uint64_t sC = (hasS)         ? ld64_cg(input + baseS + wcol)       : 0ull;
        const std::uint64_t sR = (hasS && hasR) ? ld64_cg(input + baseS + (wcol + 1)) : 0ull;

        // Build the eight neighbor bitboards for this word by aligning horizontal neighbors with shifts.
        // From the north row
        const std::uint64_t N_left   = shl1_with_carry(nC, nL);
        const std::uint64_t N_center = nC;
        const std::uint64_t N_right  = shr1_with_carry(nC, nR);

        // From the south row
        const std::uint64_t S_left   = shl1_with_carry(sC, sL);
        const std::uint64_t S_center = sC;
        const std::uint64_t S_right  = shr1_with_carry(sC, sR);

        // From the center row (exclude the cell itself, include only left and right neighbors)
        const std::uint64_t C_left   = shl1_with_carry(cC, cL);
        const std::uint64_t C_right  = shr1_with_carry(cC, cR);

        // Lane-wise addition of the eight neighbor masks using carry-save adders.
        // First, group into three CSAs:
        std::uint64_t s0, c0;
        csa_u64(N_left, N_center, N_right, s0, c0);

        std::uint64_t s1, c1;
        csa_u64(S_left, S_center, S_right, s1, c1);

        std::uint64_t s2, c2;
        csa_u64(C_left, C_right, 0ull, s2, c2);

        // Combine sums of ones from the three groups:
        std::uint64_t ones, c3;
        csa_u64(s0, s1, s2, ones, c3);  // ones: bit 0 of count; c3: carries (weight 2)

        // Combine all "twos" (carries) from previous stages: c0, c1, c2, and c3.
        // They are all weight-2 contributions; we reduce them to twos (bit1) and fours (bit2).
        std::uint64_t t0, f0;
        csa_u64(c0, c1, c2, t0, f0);    // t0: partial twos (parity), f0: partial fours (carry from twos)

        std::uint64_t twos, f1;
        csa_u64(t0, c3, 0ull, twos, f1); // twos: bit 1 of count, f1: more fours

        // Fours bit (bit 2 of count) is parity of the two four-carry sources.
        const std::uint64_t fours = f0 ^ f1;

        // Game of Life rules:
        // births happen where count == 3 (0b011): (~fours) & twos & ones
        // survives happen where count == 2 (0b010): (~fours) & twos & (~ones), only if currently alive
        const std::uint64_t births   = (~fours) & twos & ones;
        const std::uint64_t survives = (~fours) & twos & (~ones) & cC;

        output[idx] = births | survives;
    }
}

/* Host function to execute one step of the Game of Life.
   - input:  bit-packed current grid (device pointer)
   - output: bit-packed next grid (device pointer)
   - grid_dimensions: width/height of the square grid in cells (power of two, >512)
*/
void run_game_of_life(const std::uint64_t* input, std::uint64_t* output, int grid_dimensions)
{
    // Number of 64-bit words per row (grid_dimensions is divisible by 64)
    const int words_per_row = grid_dimensions >> 6;
    const std::size_t total_words = static_cast<std::size_t>(grid_dimensions) * static_cast<std::size_t>(words_per_row);

    // Choose launch configuration. 256 threads per block is a good default for bitwise workloads.
    constexpr int block_size = 256;
    const int grid_size = static_cast<int>((total_words + block_size - 1) / block_size);

    gol_step_kernel<<<grid_size, block_size>>>(input, output, grid_dimensions, words_per_row);
}

// The content below was not generated by GPT; it was added to ensure the framework can compile the code.


void run_game_of_life(const bool* input, bool* output, int grid_dimensions) {
    (void)input;
    (void)output;
    (void)grid_dimensions;
}

void initialize_internal_data_structures(int grid_dimensions) {
    (void)grid_dimensions;
}

// This label is used by the framework to identify the memory layout of the input and output arrays.
// MEMORY_LAYOUT: ROWS
