#include <cuda_runtime.h>

// Optimized CUDA kernel for one simulation step of Conway's Game of Life.
// This kernel uses a shared-memory tiling technique to minimize global memory accesses.
// Each CUDA block loads a tile of the grid into shared memory along with a 1-cell-wide halo.
__global__ void game_of_life_kernel(const bool* __restrict__ d_input, bool* __restrict__ d_output, int grid_dim)
{
    // Define block dimensions and compute block's starting indices in the global grid.
    // Each block processes a blockDim.x x blockDim.y segment of the grid.
    const int bx = blockDim.x;
    const int by = blockDim.y;
    const int blockStartX = blockIdx.x * bx;
    const int blockStartY = blockIdx.y * by;

    // Global coordinates for this thread's corresponding cell.
    const int globalX = blockStartX + threadIdx.x;
    const int globalY = blockStartY + threadIdx.y;

    // Shared memory tile dimensions with a 1-cell halo on each side.
    const int sh_w = bx + 2;
    const int sh_h = by + 2;

    // Declare shared memory array.
    extern __shared__ bool s_data[];

    // Each thread cooperatively loads data into shared memory.
    // We use a linearized iteration so that all the (bx+2) * (by+2) elements are loaded.
    const int total_shared_elements = sh_w * sh_h;
    const int threadId = threadIdx.y * bx + threadIdx.x;
    const int blockThreads = bx * by;
    for (int idx = threadId; idx < total_shared_elements; idx += blockThreads)
    {
        // Compute shared memory (x,y) coordinates.
        int s_x = idx % sh_w;
        int s_y = idx / sh_w;
        // Compute corresponding global coordinates.
        int g_x = blockStartX + s_x - 1;
        int g_y = blockStartY + s_y - 1;
        // Only load from global memory if within grid bounds; otherwise, treat as dead.
        if (g_x >= 0 && g_x < grid_dim && g_y >= 0 && g_y < grid_dim)
            s_data[idx] = d_input[g_y * grid_dim + g_x];
        else
            s_data[idx] = false;
    }
    // Ensure all threads have loaded the data into shared memory.
    __syncthreads();

    // Only process valid global cells.
    if (globalX < grid_dim && globalY < grid_dim)
    {
        // Compute the shared memory index for this thread's cell.
        const int s_center_x = threadIdx.x + 1;
        const int s_center_y = threadIdx.y + 1;
        const int s_index = s_center_y * sh_w + s_center_x;

        // Unroll the neighbor summation for performance.
        int live_neighbors = 0;
        live_neighbors += s_data[s_index - sh_w - 1]; // top-left
        live_neighbors += s_data[s_index - sh_w];     // top
        live_neighbors += s_data[s_index - sh_w + 1];   // top-right
        live_neighbors += s_data[s_index - 1];          // left
        live_neighbors += s_data[s_index + 1];          // right
        live_neighbors += s_data[s_index + sh_w - 1];     // bottom-left
        live_neighbors += s_data[s_index + sh_w];         // bottom
        live_neighbors += s_data[s_index + sh_w + 1];     // bottom-right

        // Apply Conway's rules.
        bool current_alive = s_data[s_index];
        bool next_state = false;
        if (current_alive)
        {
            // Alive cell survives only if it has 2 or 3 live neighbors.
            next_state = (live_neighbors == 2 || live_neighbors == 3);
        }
        else
        {
            // Dead cell becomes alive if it has exactly 3 live neighbors.
            next_state = (live_neighbors == 3);
        }

        // Write the computed state to the output grid.
        d_output[globalY * grid_dim + globalX] = next_state;
    }
}

// Host function that executes one step of Conway's Game of Life.
// 'input'  - device pointer to the input grid (each cell is stored as bool).
// 'output' - device pointer to the output grid (each cell is stored as bool).
// 'grid_dimensions' - the width (and height) of the square grid.
void run_game_of_life(const bool* input, bool* output, int grid_dimensions)
{
    // Choose a block size of 32x32 threads for optimum occupancy on modern GPUs.
    const dim3 blockDim(32, 32);
    // Compute grid dimensions to cover the entire grid.
    const dim3 gridDim((grid_dimensions + blockDim.x - 1) / blockDim.x,
                       (grid_dimensions + blockDim.y - 1) / blockDim.y);

    // Compute the required shared memory size: each block requires a (blockDim.x+2) x (blockDim.y+2) tile.
    const size_t shared_mem_size = (blockDim.x + 2) * (blockDim.y + 2) * sizeof(bool);

    // Launch the kernel.
    // Note: Any necessary host-device synchronization is assumed to be handled by the caller.
    game_of_life_kernel<<<gridDim, blockDim, shared_mem_size>>>(input, output, grid_dimensions);
}

// The content below was not generated by GPT; it was added to ensure the framework can compile the code.


#include <cstdint>
void run_game_of_life(const std::uint64_t* input, std::uint64_t* output, int grid_dimensions) {
    (void)input;
    (void)output;
    (void)grid_dimensions;
}

void initialize_internal_data_structures(int grid_dimensions) {
    (void)grid_dimensions;
}
// this label is used to identify the memory layout of the input and output arrays by the framework
// MEMORY_LAYOUT: BOOLS
